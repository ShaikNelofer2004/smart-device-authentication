const Device = require('../models/Device');
const User = require('../models/User');
const GeneratedQRCode = require('../models/GeneratedQRCode');

// Add a new device
exports.addDevice = async (req, res) => {
  try {
    const { qrCode } = req.body;
    
    // Check if QR code is valid (optional, e.g., 16 digits)
    if (!qrCode || qrCode.length !== 16 || !/^\d+$/.test(qrCode)) {
      return res.status(400).json({ msg: 'Invalid QR code format. Must be 16 digits.' });
    }

    // Check if the QR code is a valid, unused code generated by an admin
    const generatedCode = await GeneratedQRCode.findOne({ qrCode });
    if (!generatedCode) {
      return res.status(400).json({ msg: 'This QR code is not valid.' });
    }
    if (generatedCode.isUsed) {
      return res.status(400).json({ msg: 'This QR code has already been used.' });
    }

    // Mark the code as used and create the device
    generatedCode.isUsed = true;
    generatedCode.usedBy = req.user.id;
    generatedCode.usedAt = Date.now();
    
    const newDevice = new Device({
      qrCode,
      userId: req.user.id,
      isActive: true
    });

    await Promise.all([generatedCode.save(), newDevice.save()]);

    res.json({ msg: 'Device added successfully', device: newDevice });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
};

// Get all devices for the current user
exports.getUserDevices = async (req, res) => {
  try {
    const devices = await Device.find({ userId: req.user.id, isActive: true }).sort({ createdAt: -1 });
    res.json(devices);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
};

// Calculate distance between two points using Haversine formula
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371; // Radius of the Earth in kilometers
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c; // Distance in kilometers
  return distance;
};

// Update a device's location
exports.updateDeviceLocation = async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { latitude, longitude, locationName, locationType, accuracy, speed, heading } = req.body;
    const device = await Device.findById(deviceId);
    if (!device) return res.status(404).json({ msg: 'Device not found' });
    if (!device.isActive) return res.status(400).json({ msg: 'Device is not active' });
    const now = new Date();
    
    // Calculate distance if previous location exists
    let distanceIncrement = 0;
    if (device.currentLocation && device.currentLocation.latitude != null && device.currentLocation.longitude != null) {
      distanceIncrement = calculateDistance(
        device.currentLocation.latitude,
        device.currentLocation.longitude,
        latitude,
        longitude
      );
    }
    
    device.currentLocation = {
      latitude,
      longitude,
      locationName: locationName || device.currentLocation.locationName,
      locationType: locationType || device.currentLocation.locationType,
      lastUpdated: now
    };
    device.isOnline = true;
    device.isTracking = true;
    
    // Update total distance
    device.totalDistance += distanceIncrement;
    
    // Add to locationHistory only if different from last point
    device.locationHistory = device.locationHistory || [];
    const last = device.locationHistory[device.locationHistory.length - 1];
    if (!last || last.latitude !== latitude || last.longitude !== longitude) {
      device.locationHistory.push({
        latitude,
        longitude,
        locationName: locationName || device.currentLocation.locationName,
        locationType: locationType || device.currentLocation.locationType,
        lastUpdated: now,
        accuracy,
        speed,
        heading,
        timestamp: now
      });
    }
    await device.save();
    res.json({ 
      msg: 'Device location updated', 
      device: {
        ...device.toObject(),
        distanceIncrement: distanceIncrement.toFixed(4),
        totalDistance: device.totalDistance
      }
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
};

// Get all devices with locations (admin/superadmin)
exports.getAllDevicesWithLocations = async (req, res) => {
  try {
    // Get all active devices regardless of online status
    const devices = await Device.find({ isActive: true }).populate('userId', 'name email role');
    
    // Update online status based on last location update
    const now = new Date();
    const OFFLINE_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds
    
    const updatedDevices = devices.map(device => {
      const lastUpdate = device.currentLocation?.lastUpdated;
      const isOnline = lastUpdate && (now - new Date(lastUpdate) < OFFLINE_THRESHOLD);
      return {
        ...device.toObject(),
        isOnline: isOnline
      };
    });
    
    res.json(updatedDevices);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
};

// Mark a device as offline
exports.markDeviceOffline = async (req, res) => {
  try {
    const { deviceId } = req.params;
    const device = await Device.findById(deviceId);
    if (!device) return res.status(404).json({ msg: 'Device not found' });
    device.isOnline = false;
    device.isTracking = false;
    await device.save();
    res.json({ msg: 'Device marked offline', device });
  } catch (err) {
    res.status(500).send('Server error');
  }
};

// Get location history for a device
exports.getDeviceLocationHistory = async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { startDate, endDate } = req.query;
    
    const device = await Device.findById(deviceId);
    if (!device) return res.status(404).json({ msg: 'Device not found' });
    
    let locationHistory = device.locationHistory || [];
    
    // Filter by date range if provided
    if (startDate || endDate) {
      locationHistory = locationHistory.filter(location => {
        const locationDate = new Date(location.timestamp || location.lastUpdated);
        const start = startDate ? new Date(startDate) : null;
        const end = endDate ? new Date(endDate) : null;
        
        // If only start date is provided
        if (start && !end) {
          return locationDate >= start;
        }
        // If only end date is provided
        if (end && !start) {
          return locationDate <= end;
        }
        // If both dates are provided
        if (start && end) {
          return locationDate >= start && locationDate <= end;
        }
        return true;
      });
    }
    
    res.json(locationHistory);
  } catch (err) {
    console.error('Error in getDeviceLocationHistory:', err);
    res.status(500).json({ msg: 'Server error' });
  }
}; 

// Delete device by ID
exports.deleteDevice = async (req, res) => {
  try {
    const { deviceId } = req.params;
    const device = await Device.findByIdAndDelete(deviceId);
    if (!device) return res.status(404).json({ msg: 'Device not found' });
    // Mark as inactive if found (soft delete pattern)
    if (device) {
      device.isActive = false;
      await device.save();
    }
    res.json({ msg: 'Device deleted', device });
  } catch (err) {
    res.status(500).json({ msg: 'Server error' });
  }
};

// Delete device by QR code
exports.deleteDeviceByQrCode = async (req, res) => {
  try {
    const { qrCode } = req.params;
    const device = await Device.findOneAndDelete({ qrCode });
    if (!device) return res.status(404).json({ msg: 'Device not found' });
    // Mark as inactive if found (soft delete pattern)
    if (device) {
      device.isActive = false;
      await device.save();
    }
    res.json({ msg: 'Device deleted', device });
  } catch (err) {
    res.status(500).json({ msg: 'Server error' });
  }
};